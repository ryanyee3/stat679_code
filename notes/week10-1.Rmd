---
title: Structured Graphs
layout: post
output:
  md_document:
    preserve_yaml: true
---

_Representing known structure in graphs_

```{r, echo = FALSE}
library(knitr)
opts_knit$set(base_dir = "/", base.url = "/")
opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  fig.path = "stat679_notes/assets/week10-1/"
)
```

1. Graph layouts can often benefit from additional information known about the
structure of the graph or purpose of the visualization. These notes describe a
few of the situations that arise most frequently in practice.

1. When there is no additional structure / specific purpose, a reasonable
default for node-link diagrams uses force-directed layout, as discussed previously. In this layout, we
think of nodes as particles that want to repel one another, but which are tied
together by elastic edges.

1. One common situation where we can go beyond force-directed graphs is when we
have additional information about the nodes that can be used to constrain their
position. For example, the Royal Constellations visualization, attempts to
visualize the family trees of royal families. On the y-axis, the nodes are
constrained to be sorted by year, and across the x-axis, nodes are constrained
according to the country of the royal family.

<iframe src="https://royalconstellations.visualcinnamon.com/" width=800 height=500></iframe>

1. More generally, we can define x and y-axis constraints and then use a
force-directed algorithm to layout the nodes, subject to those constraints.
These can be implemented by combining D3 with the [cola library](https://ialab.it.monash.edu/webcola/). For example, we've simulated data that are known to fall into three tight clusters, but using a naive force-directed layout leads to clusters that cross one another.

    <iframe src="https://krisrs1128.github.io/stat679_code/examples/week10/week10-1/cola-example.html" data-external="1" height=400 width=500></iframe>

1. To resolve this, we can explicitly tell the layout algorithm to constrain the x-coordinates for nodes within each cluster.

    <iframe src="https://krisrs1128.github.io/stat679_code/examples/week10/week10-2/cola-example.html" data-external="1" height=400 width=500></iframe>

    To accomplish this, we defined an array of objects specifying pixel
    constraints between pairs of nodes; e.g., `{"axis":"y", "left":0, "right":1,
    "gap":25}` says that node 1 should be (at least) 25 pixels above node 0.


```{r eval = FALSE}
let constrained = cola.d3adaptor()
  .nodes(nodes)
  .links(links)
  .constraints(constraints)
  .groups(groups)
  .start()
```

1. Another common situation is that the nodes can be organized into a hierarchy
of subgraphs. That is, nodes can be partitioned into non-overlapping sets. These
sets can themselves be merged together to define a coarser partition.

1. This hierarchical structure can be encoded in either node-link or adjacency
matrix visualizations. For example, in node-link views, we can draw shapes
enclosing the sets,

	and in adjacency matrices, we can draw trees specifying the hierarchy.

1. We can in fact use the cola library to encode hierarchy in node-link views.
The example below uses cola to ensure sets don’t overlap. It then draws (and
fills in) paths that contain the separate sets.

1. In some graphs, we have clustering structure. Within each cluster, nodes are
densely connected, but between clusters, there are only a few links. In this
case, it’s natural to use adjacency matrices to visualize the clusters and then
draw links for connections between adjacency matrices. The reasoning is that
adjacency matrices are better suited in densely connected graphs (they don’t
have the edge crossing problem) but node-link encodings are better when we want
to follow longer paths across clusters.

1. This is just one example of a larger class of “hybrid” matrix encodings.
It’s possible to solve a variety of visual problems, just by cleverly combining
the elementary visual encodings discussed last week.

1. So far, we have focused on high-level properties of the graph that can be
accounted for in visualization. Sometimes, the intended function of the
visualization warrants thinking at a low-level instead. For example, in many
problems, we are interested in studying ego-networks — the small neighborhoods
that surround specific nodes of interest.

1. One example of a layout that was designed to support ego-network
visualization is the egoCompare system. This is a kind of overview + detail
graph visualization where users can select pairs of nodes to compare within an
overview graph. The 2-nearest-neighbor graphs for each of these selected nodes
are then shown (and linked together, if applicable). The subgraphs are arranged
in a way that minimizes the amount of crossing.

1. The last type of graph we’ll consider in these notes are dynamic graphs.
These are graphs where the sets of nodes and links are evolving over time. For
example, the interactions between proteins in a protein interaction network may
change when a cell is exposed to environmental stress, like the presence of a
virus.

1. There is no single way to visualize these networks, but common strategies
include use of animation,
	faceting over time,
	combined encodings (like time series within nodes),
	or coordinated views.

1. In these notes, we’ve see some academic literature on visualization. Even
for those of us who are more practically oriented, this literature can be worth
being familiar, if only because it can be a treasure trove of visual problem
solving devices.
